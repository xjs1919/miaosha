# 秒杀
电商网站的秒杀

## 技术架构
SpringBoot + Redis + RabbitMQ

### 教学视频

[猛戳这里](http://coding.imooc.com/class/168.html)

### 原理

秒杀与其他业务最大的区别在于：秒杀的瞬间，（1）系统的并发量会非常的大（2）并发量大的同时，网络的流量也会瞬间变大。

关于（2），最常用的办法就是做页面静态化，也就是常说的前后端分离，把静态页面直接缓存到用户的浏览器端，所需要的数据从服务端接口动态获取。这样会大大节省网络的流量，再加上CDN，一般不会有大问题。

关于（1），这里的核心问题就在于如何在大并发的情况下能保证DB能扛得住压力，因为大并发的瓶颈在于DB。如果说请求直接从前端透传到DB，显然，DB是无法承受几十万上百万甚至上千万的并发量的。所以，我们能做的只能是减少对DB的访问，前端发出了100万个请求，通过我们的处理，最终只有10个会访问DB，这样就可以了！针对秒杀这种场景，因为秒杀商品的数量是有限的，这种做法刚好适用！

那么具体是如何来减少DB的访问呢？

假如：某个商品可秒杀的数量是10，那么在秒杀活动开始之前，把商品的ID和数量加载到缓存，比如：Redis。服务端收到请求的时候，首先减一下Redis里面的数量，如果数量减到0随后的访问直接返回秒杀失败。也就是说，只有10个请求最终会去实际的请求DB。

当然，如果我们的商品数比较多，1万件商品参与秒杀，1万*10=10万个并发去请求DB，DB的压力还是会很大，这里就用到另一个非常重要的组件：消息队列。我们不是把请求直接去访问DB，而是先把请求写到消息队列，做一个缓存，然后再去慢慢的更新数据库。这样做以后，前端用户的请求可能不会立即得到响应是成功还是失败，很可能得到的是一个排队中的返回值，这个时候，需要客户端再去服务端轮询，因为我们不能保证一定就秒杀成功了。当服务端出队，生成订单以后，把用户ID和商品ID写到缓存中，来应对客户端的轮询就可以了。

这样处理以后，我们的应用是可以很简单的进行分布式横向扩展的，以应对更大的并发。

当然，秒杀系统还有很多要处理的事情：比如防刷限流、比如分布式Session等等。具体的细节可以看视频：[猛戳这里](http://coding.imooc.com/class/168.html)

